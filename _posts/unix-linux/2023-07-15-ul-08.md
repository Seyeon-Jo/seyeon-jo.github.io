---
title: "[Unix-Linux] Processes Management"

categories:
  - Unix-Linux
tags:
  - [Process, Management]

toc: true
toc_sticky: true

date: 2023-07-15
last_modified_at: 2023-07-15
---

{% capture notice-2 %}

ðŸ“‹ This is my note-taking from what I learned in the Unix/Linux Tutorial!

- Reference link: <https://www.tutorialspoint.com/unix/index.htm>
  {% endcapture %}

<div class="notice--danger">{{ notice-2 | markdownify }}</div>

<!-- ðŸ“‹ This is my note-taking from what I learned in the UNIX/LINUX Tutorial!
{: .notice--danger} -->

<br>

# Process Management

Process management in Unix involves the creation and management of processes when executing programs. Each program execution creates a separate process with a unique Process ID(PID). The PID serves as a five-digit ID number assigned by the operating system to track and identify each process.

When a command is issued in Unix, a new process is started. A process can be seen as an instance of a running program. The operating system maintains the list of active processes and assigns unique PIDs to each process.

It is important to note that PIDs are not permanent and can eventually repeat as all possible numbers are used up. However, at any given time, no two processes in the system have the same PID. The PID is crucial for Unix to manage and monitor individual processes.

&rarr; Process management in Unix involves `creating`, `tracking`, and `identifying` processes using unique `PIDs` assigned by the operating system.

<br>

# Starting a Process

When we start a process(run a command), there 2 ways to run:

- Foreground Processes
- Background Processes

## Foreground Processes

By default, every process runs in the foreground. It gets its input from the keyboard and sends its output to the screen.

List all the files with the names which start with `ch` and end with `.doc` using `ls` command:

```
$ls ch*.doc
ch01-1.doc   ch010.doc  ch02.doc    ch03-2.doc
ch04-1.doc   ch040.doc  ch05.doc    ch06-2.doc
ch01-2.doc   ch02-1.doc
```

While a program is running in the foreground and is time-consuming, no other commands can be run because the prompt would not be available until the program finishes processing and comes out.

## Background Processes

A background process runs without being connected to keyboard. If the background process requires any keyboard input, it waits.

The advantages of running a process in the background is that we can run other commands; Do not need to wait until it completes to start another!

```
$ls ch*.doc &
[1] 17741
$ch01-1.doc   ch010.doc  ch02.doc    ch03-2.doc   ch04-1.doc   ch040.doc  ch05.doc    ch06-2.doc    ch01-2.doc   ch02-1.doc

[1]   +   Done                 ls ch*.doc &
$
```

- The line `[1] 17741` contains information about the background process - the job number and the process ID. &rarr; We need to know the job number to manipulate it between the background and the foreground.
- The line `[1]   +   Done                 ls ch*.doc &` tells us that the `ls` command background process finished successfully. And the second is a prompt for another command.

<br>

# Listing Running Processes

Run the `ps`(process status) to see our own processes:

```
$ps
PID       TTY      TIME        CMD
18358     ttyp3    00:00:00    sh
18361     ttyp3    00:01:31    abiword
18789     ttyp3    00:00:00    ps
```

Run the `-f`(f for full) option to provide more information:

```
$ps -f
UID      PID  PPID C STIME    TTY   TIME CMD
amrood   6738 3662 0 10:23:03 pts/6 0:00 first_one
amrood   6739 3662 0 10:22:54 pts/6 0:00 second_one
amrood   3662 3657 0 08:10:53 pts/6 0:00 -ksh
amrood   6892 3662 4 10:51:50 pts/6 0:00 ps -f
```

Description of all the fields displayed by `ps -f` command:

| Column | Description                                                  |
| :----- | :----------------------------------------------------------- |
| UID    | User ID that this process belongs to (the person running it) |
| PID    | Process ID                                                   |
| PPID   | Parent process ID (the ID of the process that started it)    |
| C      | CPU utilization of process                                   |
| STIME  | Process start time                                           |
| TTY    | Terminal type associated with the process                    |
| TIME   | CPU time taken by the process                                |
| CMD    | The command that started this process                        |

Other options which can be used along with `ps` command:

| Option | Description                                         |
| :----- | :-------------------------------------------------- |
| `-a`   | Shows information about all users                   |
| `-x`   | Shows information about processes without terminals |
| `-u`   | Shows additional information like -f option         |
| `-e`   | Displays extended information                       |

<br>

# Stopping Processes

Ending a process can be done in several different ways:

- Foreground mode
  : `CTRL + C` keystroke(the default interrupt character) will exit the command.
- Background mode
  : Get `Job ID` using the `ps` command, and then use the `kill` command to kill the process

Background mode using `kill` command:

```
$ps -f
UID      PID  PPID C STIME    TTY   TIME CMD
amrood   6738 3662 0 10:23:03 pts/6 0:00 first_one
amrood   6739 3662 0 10:22:54 pts/6 0:00 second_one
amrood   3662 3657 0 08:10:53 pts/6 0:00 -ksh
amrood   6892 3662 4 10:51:50 pts/6 0:00 ps -f
$kill 6738
Terminated
```

The above `kill` command terminates the `first_one` process. If a process ignores a regular `kill` command, use `kill -9` command:

```
$kill -9 6738
Terminated
```

<br>

# Parent and Child Processes

Unix process has 2 ID numbers:

- Process ID(PID)
- Parent Process ID(PPID)

Each user process in the system has a `parent process`.

Most of the commands that we run have the `shell` as their parent. &rarr; Use `ps -f` command to check process ID and parent process ID.

<br>

# Orphan and Zombie Processes

- Orphan Processes
  : There are cases where the parent process is terminated or killed before its child process.
  : - When this happens, the child process becomes an orphan because it no longer has a parent to take care of it.
  : - In such case, the operating system designates the `parent of all processes`, known as the `init process` as the new parent of the orphan process.
  : - The `init process` takes on the responsibility of managing orphan processes and ensuring they are properly handled.
- Zombie Processes
  : When a process is killed, its entry in the process table is not immediately removed. Instead, it remains in a `zombie` or `defunct` state.
  : - A zombie process is essentially a dead process that is not being used anymore.
  : - The reason for keeping zombie processes temporarily is to allow the parent process to collect the exit status of its terminated child process.
  : - Once the parent process collects this information, the zombie process is removed from the process table entirely.

The zombie processes are different from the orphan processes. The zombie processes have completed execution but still find an entry in the process table.

<br>

# Daemon Processes

Daemons are special types of background processes that run on a computer system. They are typically responsible for handling system-related tasks or providing services to other processes.

- Run without a controlling terminal. &rarr; This means that it doesn't interact directly with a user or require input from a terminal device.
  : If we look at the process listing using the `ps -ef` command, we will notice that daemons have a `?` symbol in the `tty` field, indicating the absence of a terminal.
- Run with elevated permissions, such as root, which gives them the necessary privileges to perform system-level tasks or access restricted resources.

Primary purpose of a daemon is to wait for specific events or requests to occur that it can handle or process. &rarr; A printer daemon waits for print commands from other processes and manages the printing process in the background.

- If a program is required lengthy processing or needs to run continuously in the background, it is beneficial to turn it into a daemon.
- Running it as a daemon allows the program to operate independently without blocking other tasks or requiring constant user interaction.

<br>

# The top Command

The `top` command is useful to quickly show processes sorted by various criteria. It is an interactive diagnostic tool that updates frequently and shows information about physical and virtual memory, CPU usage, load averages, and our busy processes.

Run `top` command and see the statistics of CPU utilization by different processes:

```
$top
```

<br>

# Job ID Versus Process ID

Background and suspended processes are usually manipulated via `job number(job ID)`. This number is different from the process ID and is used because it is shorter.

A job can consist of multiple processes running in a series or at the same time, in parallel. Using the job ID is easier than tracking individual processes.

<br>

---

<br>

[Back to Top](#){: .btn .btn--primary }{: .align-right}
