---
title: "[Arrays] Sort Array By Parity"

categories:
  - Arrays
tags:
  - [Sort]

toc: true
toc_sticky: true

date: 2023-05-06
last_modified_at: 2023-05-08
---

<!-- {% capture notice-2 %}

üìã This is the tech-news archives to help me keep track of what I am interested in!

- Reference tech news link: <https://thenextweb.com/news/blockchain-development-tech-career>
  {% endcapture %}

<div class="notice--danger">{{ notice-2 | markdownify }}</div> -->

üìã This is my note-taking from what I learned in LeetCode!
{: .notice--danger}

<br>

# Problem

[Problem Link](https://leetcode.com/explore/learn/card/fun-with-arrays/511/in-place-operations/3260/)

Given an integer array nums, move all the even integers at the beginning of the array followed by all the odd integers.

Return any array that satisfies this condition.

Example 1:

- Input: nums = [3,1,2,4]
- Output: [2,4,3,1]
- Explanation: The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.

Example 2:

- Input: nums = [0]
- Output: [0]

Constraints:

1 <= nums.length <= 5000
0 <= nums[i] <= 5000

<br>

# Solution

[Solution Link](https://leetcode.com/problems/sort-array-by-parity/editorial/)

## Approach 1: Sort

Use a custom comparator when sorting, to sort by parity.

Algorithm:

1. Sort the input list "nums" based on the remainder of each element when divided by 2. The key function used for sorting is a lambda function that returns the result of x%2 for each element x in the list.
2. Return the sorted list as the output. The sorted list will have all the even numbers first, followed by all the odd numbers.

```
def sortArrayByParity(nums: list[int]) -> list[int]:
    nums.sort(key=lambda x: x % 2)
    return nums

nums = [3, 1, 2, 4]
sorted_nums = sortArrayByParity(nums)
print(sorted_nums)
```

Complexity Analysis

- Time Complexity: O(Nlog‚Å°N), where N is the length of A.
- Space Complexity: O(N) for the sort, depending on the built-in implementation of sort.

<br>

## Approach 2: Two Pass

Algorithm:

```
def sortArrayByParity(nums: list[int]) -> list[int]:
    return [x for x in nums if x % 2 == 0] + [x for x in nums if x % 2 == 1]

nums = [3, 1, 2, 4]
sorted_nums = sortArrayByParity(nums)
print(sorted_nums)
```

Complexity Analysis

- Time Complexity: O(N), where N is the length of A.
- Space Complexity: O(N), the space used by the answer.

<br>

## Approach 3: In-Place

If we want to do the sort in-place, we can use quicksort, a standard textbook algorithm.

Algorithm:

We'll maintain two pointers i and j. The loop invariant is everything below i has parity 0 (ie. A[k] % 2 == 0 when k < i), and everything above j has parity 1.

Then, there are 4 cases for (A[i] % 2, A[j] % 2):

- If it is (0, 1), then everything is correct: i++ and j--.
- If it is (1, 0), we swap them so they are correct, then continue.
- If it is (0, 0), only the i place is correct, so we i++ and continue.
- If it is (1, 1), only the j place is correct, so we j-- and continue.

Throughout all 4 cases, the loop invariant is maintained, and j-i is getting smaller. So eventually we will be done with the array sorted as desired.

```
def sortArrayByParity(nums: list[int]) -> list[int]:
    i, j = 0, len(nums) - 1
    while i < j:
        if nums[i] % 2 > nums[j] % 2:
            nums[i], nums[j] = nums[j], nums[i]
        if nums[i] % 2 == 0:
            i += 1
        if nums[j] % 2 == 1:
            j -= 1
    return nums

nums = [3, 1, 2, 4]
sorted_nums = sortArrayByParity(nums)
print(sorted_nums)
```

Complexity Analysis

- Time Complexity: O(N), where N is the length of A. Each step of the while loop makes j-i decrease by at least one. (Note that while quicksort is O(Nlog‚Å°N) normally, this is O(N) because we only need one pass to sort the elements.)
- Space Complexity: O(1) in additional space complexity.

<br>

---

<br>

[Back to Top](#){: .btn .btn--primary }{: .align-right}
